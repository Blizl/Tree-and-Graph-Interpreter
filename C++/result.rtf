{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fmodern\fcharset0 CourierNewPSMT;\f1\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww20160\viewh15880\viewkind0
\deftab720
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs29\fsmilli14667 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Jae Kim and Victor Liang
\f1\fs24 \
\pard\pardeftab720\sl400\qc\partightenfactor0

\f0\fs29\fsmilli14667 \cf2 Project 5 
\f1\fs24 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs29\fsmilli14667 \cf2 For project, 5 a local search algorithms were used to solve the knapsack and graph coloring instances. While not necessarily getting the global optimum, these methods were used to find the local optimum. The local optimum was found using by first getting an initial solution, then using a neighboring function, which we chose to be 2-opt in this case, used a steepest descent search, and then finally used an advanced local search algorithm, which was the tabu search algorithm for knapsack and optimized local search finder for graph coloring.
\f1\fs24 \
\pard\pardeftab720\sl320\partightenfactor0
\cf2 \'a0\
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs29\fsmilli14667 \cf2 Knapsack
\f1\fs24 \
\pard\pardeftab720\sl320\partightenfactor0
\cf2 \'a0\
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs29\fsmilli14667 \cf2 For knapsack, the initial solution that we chose was the greedy solution. We ordered the knapsack by their weight/cost ratio and kept adding the items into the bag until there were no more items that could be added within the cost limit. With the neighboring function, a swap was done with a selected object and an unselected object. If an object was selected, we would unselect it and select an unselected object, but only if removing the object and adding the new object would stay within the cost limit. The steepest descent algorithm is to choose the best neighbor so you can find the local optimum, so that is exactly what we did. We would keep swapping, moving toward the local optimum because we only swap when the value increases, thus choosing the best neighbor, which is the definition of the steepest descent algorithm. We then implemented the tabu search algorithm where we maintained a tabu list of objects that we swapped within the knapsack. This would get rid of the possibility that we would swap the same two values again. This resulted in the tabu search running much faster because it did not check for the items inside the tabu list. Comparing and contrasting the solutions from previous projects, the local search algorithms most closely resembles the greedy algorithm while providing a solution much closer to optimal while maintaining polynomial time speed, whereas something like exhaustive search would require O(2^n) run time. These solutions find the local optimum which in some cases may even be the global optimum. 
\f1\fs24 \
\pard\pardeftab720\sl320\partightenfactor0
\cf2 \'a0\
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs29\fsmilli14667 \cf2 Graph Coloring
\f1\fs24 \
\pard\pardeftab720\sl320\partightenfactor0
\cf2 \'a0\
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs29\fsmilli14667 \cf2 For graph coloring, an initial solution was found by the greedy algorithm, and then a neighborhood function was to determine which neighbor to change color, and the steepest descent algorithm was used to choose the best color to choose from. Something to note is that for our project 2, we did a \'93smarter\'94 greedy algorithm that encompasses all this without knowing it would help us in this project. From project 2, we implemented a greedy algorithm that would assign a color to a node and when only assign that color based on it creating the least amount of conflicts by choosing the color that would result in the least amount of conflicts. Because of this, we changed the initial solution to logic that was less complex. The initial solution in this case would go through the graph, and assigns it to the color that has the least number of conflicts. Contrast to the previous greedy solution, the initial solution does not go through the logic of finding the best color to choose from instead assigns the first color if all colors cause a conflict. The neighboring function is also the one to determine which nodes need to have their colors changed. An advanced local search algorithm, optimized conflict solver was also implemented where locally we would determine and assign the best color with minimum conflicts at the current vertex. Comparing and contrasting the previous projects with this one, this project was similar to the greedy algorithm project and same with knapsack, provides a much better runtime as well as finding the local optimum while sometimes even finding the global optimum. 
\f1\fs24 \
}